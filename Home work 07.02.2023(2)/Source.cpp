#include <iostream>
#include <string>
#include <memory>
#include <windows.h>
#include <utility>

class Car {
	Car(){}
	void someFunc() {
		std::cout << "someFunc" << std::endl;
	}

// необходимо было функцию добавить в класс Car
void myFunc(std::unique_ptr<Car> car) {//unique_ptr нельзя копировать в функцию, можно лишь перемещать
	car->someFunc();
	return; 
}
};

int main() {
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);


	//1.Почему разработчики языка C++ отказались от auto_ptr ?
	//Существует одно самое главное правило использования std::auto_ptr[10]:
	// никогда не использовать std::auto_ptr. Этот умный указатель был помечен
	// как устаревший в C++ 11, а в C++ 17 был полностью удалён из стандарта языка.
	// Это произошло из-за вводящей в заблуждение семантики копирования auto_ptr нельзя было использовать в стандартных контейнерах
	// При копировании из одного указателя в другой, владение указателем имеет только один указатель.
	// А предыдущий указатель просто теряет информацию об адресе объекта и удаляется
	//auto_ptr очень схож с unique_ptr
	//
	//2.Чем полезны умные указатели?
	//Умные указатели в отличие от простых указателей помогают определить,
	//какой указатель объектом владеет, а какой – только использует. 
	//Не происходит утечки памяти при удалении указателя, вместе с ним вызывается деструктор с delete
	//Этого не приходится делать вручную, тем более что программист попросту может забыть это сделать
	// В случае, если одна из функций выбросит исключение, развёртывание стека защитит нас от утечки памяти.
	// В целом умные указатели были созданы для того чтобы  никогда не использовать new/delete и в них не путаться
	//3.Как устроен shared_ptr, и как он понимает, когда удалять объект, на который
	//ссылается внутри себя ?
	//Это самый популярный и часто используемый умный указатель, позволяет создавать несколько указателей на объект
	//Имеет уникальный счетчик, куда записываются все его созданные
	// указатели. Это удобно при последующем удалении указателей. Ведь теперь он знает сколько их и сколько нужно удалить не пропустив ни одного
	// А затем удалить и сам объект на который указывали указатели, чтоб он не завис в памяти
	// 
	
	//5.Скомпилируется ли данный код? (Подразумеваем, что #include <memory> написан, класс Car определен где - то выше и имеет конструктор по умолчанию).
	//Поясните.
	auto p = std::make_unique<Car>();
	//std::unique_ptr<Car> p2 = p;//этот указатель уникален и его нельзя копировать
	//можно воспользоваться таким способом
	std::unique_ptr<Car> p2 = std::move(p);//передали владение указателем p указателю p2

	
	
	//4.Корректен ли данный код ? Поясните.
	//auto car = std::make_unique<Car>();//создать указатель
	//myFunc(car);// не работает
	// 
	//семантика копирования отключена, для фактической передачи переменной
	//нужно будет использовать std::move 
	//myFunc(std::move(car));
}


